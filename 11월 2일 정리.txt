= : 대입연산자
a = b ; -> b를 a에 대입하세요.
a = 4 ; -> 4를 a에 대입하세요.



지역(local)변수 : 유지보수를 편하게 함
메서드 안에서 중복되는 데이터는 변수 처리.
클래스 안에서 중복되는 코드는 메서드 처리.
프로젝트 안에서 중복되는 메서드&변수&상수는 상속 처리

변수 선언 공식
자료형 변수명 = 자료형에 맞는 값;



자료형
1. 기본자료형
boolean, char, byte, shor, int, long, float, double

2. 참조자료형 : 기본자료형이 아닌 자료형
     참조자료형 변수명 = new 생성자();
     여기에서 new는 힙메모리 저장공간을 할당하라는 의미
     변수명 : 객체가 저장된 힙메모리의 주소값.

지역변수 vs 멤버변수
1. 지역변수 : 메서드나 생성자 안에서 선언된 변수
스코프: 선언된 순간~해당 메서드 끝까지
자료형 변수명 = 자료형에 맞는 값;
자료형 변수명; = 변수 선언
변수명 = 자료형에 맞는 값; = 대입..대입전 선언이 있어야 함
자료형 변수명 = 자료형에 맞는값; = 변수 초기화

2. 멤버변수 : 클래스의 필드에 선언
스코프 : 해당 클래스 전체
(private: 해당 클래스 이외에서 호출 불가)
private 자료형 변수명;
초기화는 생성자 안에서 이뤄짐.
객체의 구성 요소 역할을 하고..
클래스의 구성 요소..



메서드 : 객체의 기능(=능력=행위)을 표현
public 반환형 메서드명(자료형 변수명) {
     return 자료형에 맞는 값; 반환형이 void가 아닐 때.
 }

무반환 무파람: 메서드명( )
무반환 유파람: set( ) 메서드 형태, 메서드명(자료형에 맞는 값);
유반환 무파람: get( ) 메서드 형태, 반환형과 같은 자료형 변수명 = 메서드명( );
유반환 유파람: [반환형과 같은 자료형] + [변수명] = [메서드명(자료형에 맞는 값);]

메서드오버로딩(=오버로딩) -> 오버로딩은 메서드만 가능
같은 클래스 메서드 이름 같음.
파라미터의 자료형과 관련되어 있음
접근제한자 x, 반환형 x, 파라미터의 변수명 x
1. (or 조건) 메서드의 파라미터의 개수가 다르면 O
2. (or 조건) 메서드의 파라미터이 자료형이 다르면 O
3. (or 조건) 메서드의 파라미터의 자료형의 배치 순서가 다르면 O



생성자: 객체 생성 시 값을 제공, 멤버변수 초기화
디폴트 생성자 - 파라미터가 없으면 디폴트 생성자
사용자 생성자 - 파라미터가 있으면 사용자 생성자
클래스 생성시 생성자가 안보여도 디폴트 생성자가 안보이는 형태로 존재.
사용자 생성자 2개가 눈에 보일시 생성자는 2개 존재 (디폴트 생성자는 존재하지 않는다)
  >위상황에서 디폴트 생성자를 사용하고 싶을경우 직접 입력한다.
동적인 객체를 만들고 싶다.. = 사용자 생성자 사용
public 클래스명() {

}
this = 객체 자기 자신 -> 지역변수와 멤버변수의 변수명이 같을 때, 컴파일러가 지역변수를 우선적으로 인식 하기 때문에 멤버변수를 사용하고 싶다면 this.변수명을 사용하면 멤버변수를 가르킨다.
this( ) : 해당 클래스의 생성자 호출
생성자의 첫 라인에 작성해야 함



클래스와 객체
1. 객체 : 국어 사전에서 명사...힙메모리에 저장된 데이터...실체
객체 생성공식 = [참조자료형] + [객체명] = [new 생성자( );]
힙메모리에 저장됨.
참조자료형으로 만들어짐.
객체가 갖고 있는 자뤈에 접근 또는 사용할 때..
객체명.변수명;
객체명.상수명;
객체명.메서드명;

2. 클래스 : 설계도의 의미..메서드(기능)들의 묶음..class라는 키워드가 있어야 클래스..
클래스는 단독으로 실행되지 못한다..객체를 만들어서 실행해야 한다.
클래스의 구성 요소 : 멤버변수/상수, 생성자, 메서드\
객체의 구성 요소를 표현하는 자료 : 멤버변수/상수
객체의 생성법을 표현하는 자료 : 생성자
객체의 기능을 표현하는 자료 : 메서드
참조자료형의 변수(=객체=인스턴스)가 갖고 있는 자원에 접근하려면
-> 객체명.



연산자
=
+, -, *, /, %
+=, -=, *=, /=, %=
>, >=, <, <=, ==, !=
&&, ||, !
i++, ++i, i--, --i 
&, ^, ~, |
>>, <<
조건연산자(=삼함연산자)
type 변수명 = 조건식? 참일 때의 값 : 거짓일 때의 값;
type 변수명 = 조건식1 참일 때의 값 : 조건식2 참일 때의 값2 : ... : 거짓일 때의 값;



조건문
if문 = 상황에 따라 실행코드를 달리 하고 싶을 때, ~면, ~라면, ~이면
단순 if : ~면 ~해라.
if ~ else : ~면 ~하고, 그렇지 않으면 ~해라
다중 if : ~면 ~하고, 그렇지 않고 ~면, ~해라, 그렇지 않고 ~면, ~해라

switch ~ case문 : ==, int , String , enum



continue: 해당 회차를 빠져나감
break : 해당 실행문 종료
return : 해당 메서드 종료



반복문
for문



static 변수 , 상수 , 메서드
==
class 변수 , 상수 , 메서드

--------------------------
프로그램이 실행되면 곧바로 static 영역에 로딩이 되어 실행가능한 상태가 된다.
static 변수/상수 : 객체 생성 개수와 상관 없이 무조건 1개만 생성됨

static 변수 생성 방법
public static type 변수명;
public static int a;

class명.변수명


































OOOOOOOOONOOOOOOOOO
OOOOOOOONNNOOOOOOOO
OOOOOOONNNNNOOOOOOO
OOOOOONNNNNNNOOOOOO
OOOOONNNNNNNNNOOOOO
NNNNNNNNNNNNNNNNNNN
ONNNNNNNNNNNNNNNNNO
OOONNNNNNNNNNNNNOOO
OOOONNNNNNNNNNNOOOO
OOONNNNNNNNNNNNNOOO
OONNNNNNOOONNNNNNOO
ONNNOOOOOOOOOOONNNO
NOOOOOOOOOOOOOOOOON


















