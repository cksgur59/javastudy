1. 변수가 왜 중요한가?
"hello" -> "what"
"what" -> "hello"
"hello" -> "where"
"where" -> "hello"
유지보수를 위해...

2. 변수 선언 예
String msg = "hello";

3. 변수 선언 공식
자료형 변수명 = 자료형에 맞는 값;


4. 자료형
자료형은 기본자료형과 참조자료형으로 나눈다.
참조자료형은 기본자료형이 아닌 자료형이다.
기본자료형은 아래의 8개로 구성되어 있다.

boolean
- 표현값의 범위: true, false
- boolean b = true;

char
- 작은따옴표 안에 한 글자 입력
- 예) '한'
- char c = '문';

= (정수형)
     byte
     - 표현값의 범위:          -128 ~ 127

     short                         -32,768~32,767

     int
     - 표현값의 범위: 약      -2,147,483,648 ~ 2,147,483,647
     - 정수형의 기본 자료형

     long                          -9,223,372,036,854,775,808~9,223,372,036,854,775,807
     - 값 뒤에  L/l을 써줘야 한다.

=(실수형)->정밀도 
     float     0.000,000
     - 값 뒤에 F/f를 써줘야 한다.

     double  0.000,000,000,000,000
     - 실수형의 기본 자료형
자료형에 맞는 값

=============================================
=============================================

자료형 변수명 =  new 자료형( );

****
Dog클래스: 참조자료형


자료형: Dog
변수명 dog
값:  알아서 넣으세요.
=====
지역(local)변수의 스코프:
선언 이후 ~ 생성자 또는 메서드의 스코프 끝까지


지역변수: 클래스의 필드 외에서 선언된 변수
              선언된 이후부터 해당 중괄호의 
              종료 표기까지( } )
멤버변수: 클래스의 필드에 선언된 변수
              - 객체의 구성 요소
==========
1. 지역변수의 개념
   - 메서드나 생성자 안에서 선언된 변수

2. 지역변수의 스코프에 대해서 깊게 학습
   - 선언 위치 ~ 해당 변수가 선언된 곳의 }까지

3. 초기화
   - 변수를 선언할 때 값을 같이 입력해주는 것
   - 초기화 예제) int a = 3;
   - 초기화를 하지 않은 예제) int b;

4. 멤버변수의 개념
  - 클래스의 멤버로 선언된 변수
  - 생성자나 메서드의 밖에서 선언된 변수

5. 멤버변수의 일반적인 사용례
  - 초기화하지 않고 선언만 함
  - int a;
  - Dog d;

6. 멤버변수의 디폴트값
  - boolean - false
  - char - 공백
  - 정수형 및 실수형 - 0
  - 참조자료형 - null

7. (변수) 대입: 반드시 변수가 선언된 후에만 가능합니다.
  - 변수명 = 자료형에 맞는 값;
  - 예) a = 10;

============================================
============================================

변수 b는 false 값을 갖고 있는 지역변수다.
상수: 변하지 않는 데이터

리터럴: 변수나 상수 초기화, 대입 때 사용하는 구체적인 값으로 
          메모리의 메서드 영역에 저장됨.

메서드 선언 공식
접근제한자 반환형 메서드명 (파라미터자료형 파리미터변수){
	메서드 호출 시 실행 코드
}


메서드의 종류
1. 무반환 무파람
   - 생성 예제
     public void me1( ){
         sysout("무반환 무파람");
     }

   - 호출(사용) 예제
     ⓐ 같은 클래스 내에서는 me1( );
     ⓑ 다른 클래스에서는 변수 선언하듯 객체 생성 후
        객체명.me1( );


2. 무반환 유파람
   - 생성 예제
     public void printScore(String name, int score ){
         sysout(name+" " + score + "점" );
     }

   - 호출(사용) 예제
     ⓐ 같은 클래스 내에서는 printScore("kim", 86 );
     ⓑ 다른 클래스에서는 변수 선언하듯 객체 생성 후
        객체명.printScore(("김유신", 100 );

=============================================
=============================================

메서드 오버로딩 (method overloading)
- 메서드의 이름이 같아도 에러 없이 제기능이 가능한 메서드의 특징

1. 선결 조건 (and)
    - 같은 클래스에서 생성된 메서드 들
    - 메서드의 이름이 같아야 함.

2. 메서드 오버로딩 성립 조건(or)
    - 1. 파라미터(=매개변수)의 개수가 다르면 메서드 오버로딩 성립
    - 2. 파라미터의 개수가 같은데, 자료형이 다르면 메서드 오버로딩 성립
    - 3. 2번 상황에서 파라미터의 자료형의 배치 순서가 다르면 메서드 오버로딩 성립

3. 메서드 오버로딩을 사용해야 하는 때
    - 1. 메서드들의 전반적인 기능이 같은데 파라미터의 자료형이 다른 때

4. 메서드 오버로딩과 관련 없는 것들
    - 1. 접근제한자 
    - 2. 반환형
    - 3. 파라미터의 변수명
    - 4. 메서드의 본문 내용

5. 메서드 오버로딩의 장점은 메서드 호출 때 나온다

6. 메서드 오버로딩과 메서드 오버라이딩의 차이
    - 오버라이딩 : 상속 관계가 성립하는 두 클래스 에서 자식클래스가 부모클래스의 메서드 내용을 재정의(수정/삭제/추가)하는 것을 의미함.


생성자 : Class의 멤버변수를 초기화하는 클래스의 구성 요소.
	생성자는 반환형이 없다

생성자는 [디폴트 생성자]와 [사용자 생성자]로 나뉜다
	디폴트 생성자: 파리미터가 없는 생성자
	사용자 생성자: 파리미터가 있는 생성자

생성자의 기능
	1. 클래스의 멤버변수 초기화
	2. 참조자료형의 자료형에 맞는 값을 제공함

디폴트 생성자 : 파라미터가 없는 생성자
	디폴트 생성자는 
	  클래스에 생성자가 없으면, 눈에 보이자 않아도 존재함.
	  클래스에 생성자가 있으면, 디폴트 생성자가 눈에 안 보이면 안 존재함

디폴트 생성자와 사용자 생성자를 언제 구분해서  사용자 생성자를 아니 못구하는가

=====================================================
=====================================================

멤버변수나 메서드를 호출(=사용)하려면
반드시
객체(=해당변수나 메서드를 포함하고 있는 참조자료형의 변수)가 있어야 합니다

클레스 변수명 = new 생성자( );

1.생성자의 역활 : 
멤버변수 초기화
객체(=참조자료형의 변수) 생성 때, 자료형에 맞는 값으로 사용됨

2.멤버 변수의 역활:
-객체의 구성 요소를 표현함

3.지역변수
-메서드에서 중복되는 값을 표현함.

4.메서드의 역활
-객체의 기능(=능력)을 표현
-클래스 안에서 중복되는 값들을 표현함

5.디폴트 생성자는 
다른 생성자가 눈에 안 보이면 존재 한다
다른 생성자가 눈에 보이는데, 디폴트 생성자가 안보이면 없는 것

6.this : 객체 자기 자신
this를 왜 붙이느냐? 
지역변수와 멤버변수가 이름이 같으면 컴파일러는 지역변수로 인식한다
멤버변수를 가리키고 싶다면, --->this.멤버변수

this( ): 생성자 호출
해당 클래스 안에서만.
다른 생성자의 첫번째 라인에서만 호출---->대신 메서드 사용


==========객체

1. 객체는 국어사전의 명사다



2.heap 메모리에 저장된 데이터

객체 생성법
-참조자료형 변수명(=객체명=레퍼런스) = new 생성자( );

객체가 갖고 있는 자원(변수 , 메서드)을 사용하는 방법
객체명.변수명
객체명.메서드명( )



==========클래스
1. 객체의 구성 요소를 표현한 자료
2. 객체 생성법을 표현한 자료
3. 객체의 기능을 표현한 자료
4. 설계도
5. 클래스의 구성 요소 : 멤버 변수, 생성자, 메서드
6. 클래스는 절대로 단독으로 실행되지 않는다.
7. class 키워드가 있어야 클래스 입니다

========================================================
========================================================

객체와 클래스
- 객체를 생성하는 것은 다 알죠.
자료형 변수명 = new 자료형( );
객체.변수
객체.상수
객체.메서드

객체.get메서드( ).
=====
클래스
- 멤버변수, 생성자, 메서드
- 객체의 설계도
- class 키워드가 있어야 클래스입니다.
- 객체의 구성요소를 표현
- 객체 생성 방법(=참조자료형의 자료형에 맞는 값을 제공), 멤버변수 초기화
- 객체의 기능을 표현.
=====
public class Test{
	private int a;
	public Test( ){
	}
	public Test(int a){
		this.a = a;
	}

	public void fight(Test otherTeam){
		sysout(this.a > otherTeam.a);
	}
}

=====

Test t1 = new Test(3);
Test t2 = new Test(4);
Test t3 = t1;

1. Test클래스로 만들어진 객체(=인스턴스)의 개수는 몇 개인가? 2 개
2. 생성된 객체는 무엇인가?

3. 현재 t1, t2, t3에서 생성된 인스턴스변수의 개수는 몇 개인가?





==연산자

대입연산자: =, 우측의 값을 왼쪽에 대입하라.
a = b;
a = 4; 

+: 문자열과의 덧셈이 가능함
-: 
int a=0;
a = 1-a;
*:
/: 몫   1, 1, 1, 2, 2, 2, 3, 3, 3, 4, 4, 4, 5, 5, 5, 
(n/3) +1
%: 나머지
1. 배수인지 여부 확인할 때:
2. 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, 1, 2, 3, 4
n%5
1, 2,3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5, 1, 2, 3, 4, 5
n%5 +1

====

a += b  //a = a+b
-=
*=
/=
%=
==================================
논리연산자:
- &&: 연산에 참여하는 데이터가 모두 true일 때만 true, 
       그렇지 않으면 false
- ||: 연산에 참여하는 데이터에 하나라도 true가 있으면 true,
     모든 데이터가 false이면 false
- !: 데이터의 값을 반전시킴. true -> false, false -> true



=
+, -, *, /, %
+=, -=, *=, /=, %=
>, >=, <, <=, ==, !=
&&, ||, !
++, --: 1씩 증감




++a;
++이 변수 앞에 오면, 
변수의 값이 1만큼 증가합니다.
그리고 그 증가된 값은 곧바로 변수에 대입됩니다.

====
b++;
++이 변수 뒤에 오면,
변수의 값이 1만큼 증가합니다.
그러나 그 증가된 값은 나중에 해당 변수를 호출할 때 대입됩니다.



IT는 굉장히 진보적이죠,.
생각은 진보적이나
코드는 보수적입니다.

단항연산자
int a=0;
int b=0;
++a;
b++;

sysout(a);1
sysout(b);1

=============================
=
+, -, *, /, %
+=, -=, *=, /=, %=
>, >=, <, <=, ==, !=
&&, ||, !
++, --
조건(=삼항)연산자

변수명 = 3 > 4 ? "hello" : "no";
(자료형) 변수명 = 조건식 ? 참일 때의 값 : 거짓일 때의 값;



int a = 3;
int b = 5;
정수형 변수 c의 값은 
a가 b와 같으면 
44이고 
그렇지 않으면 33이다.
변수 c를 선언하시오. 
int c = a==b? 44 : 33;


A B C D F


=
+, -, *, /, %
+=, -=, *=, /=, %=
>, >=, <, <=, ==, !=
&&, ||, !
++, --
삼항연산자
---
전자제품 만들 때 사용하는

c언어...
1. 비트연산자
   &, |, ^, ~(부호반전: 양수 -> 음수일 때는 +1, 음수 -> 양수일 때는 -1)
2. 시프트연산자
  >>, <<
~(0000000 00000000 00000000 00001110)


//스위치 알고리즘=================================================
	
              private int a=0;
	
	private boolean b = false;


	public void swithint() {
		a=1-a;
		System.out.println(a);
		
	}
	
	public void swithBoolean() {
		b = !b;
		System.out.println(b);
	}

	//============================================================

========================================================
========================================================

i++, ++i, i--, --i 
&, ^, ~, |
>>, <<
조건연산자(=삼함연산자)
type 변수명 = 조건식? 참일 때의 값 : 거짓일 때의 값;
type 변수명 = 조건식1 참일 때의 값 : 조건식2 참일 때의 값2 : ... : 거짓일 때의 값;



조건문
if문 = 상황에 따라 실행코드를 달리 하고 싶을 때, ~면, ~라면, ~이면
단순 if : ~면 ~해라.
if ~ else : ~면 ~하고, 그렇지 않으면 ~해라
다중 if : ~면 ~하고, 그렇지 않고 ~면, ~해라, 그렇지 않고 ~면, ~해라

switch ~ case문 : ==, int , String , enum



continue: 해당 회차를 빠져나감
break : 해당 실행문 종료
return : 해당 메서드 종료



반복문
for문



static 변수 , 상수 , 메서드
==
class 변수 , 상수 , 메서드

--------------------------
프로그램이 실행되면 곧바로 static 영역에 로딩이 되어 실행가능한 상태가 된다.
static 변수/상수 : 객체 생성 개수와 상관 없이 무조건 1개만 생성됨

static 변수 생성 방법
public static type 변수명;
public static int a;

class명.변수명

========================================================
========================================================

1. String 클래스의 객체 생성 두 가지 방법 학습
    - 명시적 객체 생성법 vs 암시적 객체 생성법

2. 두 생성법의 차이점
    - 객체 생성 메모리 위치가 다름

3. 참조자료형에서는 ==(동일성 비교 연산자)를 사용하지 않음.
   대신 equals()(동등성 비교 메서드)을 사용함

4. 동일성 비교는 데이터와 그 저장 위치까지 확인함
    동등성 비교는 데이터만 확인함

5. String클래스의 불변적 성격으로 메모리 낭비가 발생하고 성능 저하를 보완하기 위해서
   StringBuffer클래스를 사용함

6. StringBuffer는 활용도가 떨어지므로 마지막에 toString( )을 호출하여
활용도가 높은 String클래스로 전환해준다.

========================================================
========================================================

메서드나 생성자에서 중복되는 데이터가 있을 때는 유지보수를 용이하게 하기위해 어떻게 관리하나?   변수선언

클래스에서 메서드나 생성자에 중복되는 코드가 있을 때는 유지보수를 용이하게 하기 위해서 어떻게 관리하나? 메서드

프로젝트에서 메서드나 변수 또는 상수가 중복될 때, 유지보수를 용이하게 하기 위해서 어떻게 관리해야 할까?  상속

부모클래스의 자원(변수/상수/메서드, 생성자는 불포함)을 자식클래스에서 임의로 사용할 수 있게 하는 기술.

상속이란? 부모클래스의 자원 (변수/상수/메서드, 생성자 불포함)을 자식클래스에서 임의로 사용할 수 있는 기술
-> 프로젝트에서 클래스간에 공통으로 갖고 있는 자원에 대해 유지 보수가 용이하게 관리하는 기술

2.상속표기에 사용되는 키워드는?
 extends

7. 부모클래스  : 자식클래스
 =super클래스 : sub클래스
 =기본 클래스 : 유도 클래스

8. 숨겨져있는 super( ); : 부모(super)클래스 생성자 호출

9. 부모클래스의 변수명과 자식클래스의 변수명이 같을 경우, 누가 우선적으로 인식되는가?
= 자식 클래스의 변수가 우선적으로 인식
    -> super.변수명

10. 다형성
      부모자료형 변수명 = new 자식생성자( );
      => 다형성으로 생성된 객체의 자료형은 무엇일까여?
            Car sonata2 = new Sonata( );
       
      다형성으로 만들어진 객체의 자료형은 부모자료형으로 통일된다.

11. 메서드 오버라이딩
-상속 관계가 성립하는 클래스에서 
 부모클래스가 갖고 있는 메서드의 내용을
 자식클래스에서 재정의 하는것을 말함.

-다형성으로 생성된 객체의 경우, 자료형이 부모자료형이라도 그 객체가
실행하는 메서드는 오버라이딩된 메서드다.

오버로딩과 오버라이딩에 대해서 설명하시오
-같은 클래스에서 이름이 같은 메서드가 파라미터 자료형에 따라 인정되는 문법
-상속관계가 성립하는 부모클래스와 자식클래스에서 자식클래스가 부모클래스의 
메서드를 재정의 하는 것을 의미함. 다형성으로 생성된 객체의 경우에는 자료형이
부모자료형이라도 그 객체가 호출한 메서드는 오버라이딩이 된 메서드가 실행된다.

다형성을 이용해서 객체를 만들면 자식클래스가 갖고 있는 고유자원에 접근할 수 없다
왜냐하면 자료형이 부모자료형이기 때문에 이를 해결할 수 있는 방법은 아래 들중하나를 선택해서 사용.
instanceof     getClass


Hero가 1 명 있음.
이 영웅은 3 종류의 무기가 각각 1개씩 있습니다.
총 3개 있음 Bow  1, Sword   5, Gun   10

그중 하나를 이용해 몬스터를 공격할 수 있습니다

각각의 무기의 파워는 다릅니다

영웅은 공격용 무기를 변경할 수 있습니다

========================================================
========================================================

추상화 abstract
- 추상 클래스와 추상메서드를 의미함.
- 추상 메서드를 갖고 있는 클래스는 반드시 추상클래스로 선언해야 한다.
추상클래스 선언 방법
클래스 헤더에 abstract키워드를 넣어 줌.

추상클래스 왜 사용해야 할까? 
부모클래스로는 객체를 만들지 않도록 이를 시스템적으로 강제하기 위해사 사용...

부모클래스가 갖고 있는 추상메서드를 오버라이딩하기 싫을 경우, 추상클래스로 선언
하기도 함


final : 

변수에 final이 붙으면 상수가 된다 (상수 = 값이 변하지 않는 수)

메서드에 final이 붙으면 자식클래스에서 절대로 오버라이딩하면 안되는 메서드가 된다.

클래스에 final이 붙으면 자식클래스를 만들 수 없는 클래스가 된다.



Object클래스 : 자바 최상위 부모클래스

주요 3메서드
일반적으로 상황에 맞게 이 3 개의 메서드를 오버라이딩을 해줌
상황: 객체 비교를 해야 하는 상황
1.toString( ) : sysout(msg.toString( ))
2.hashCode( ) : 객체가 어디에 저장이 되어 있는지 알려주는 메서드
3.equals( ) : 객체 동등비교 기능을 제공하는 메서드



접근제한자 (=접근제어지시자)
-public : 프로젝트 어디에서든 접근 가능

-protected : 같은 패키지에서만 접근 가능. 단, 상속관계가 
성립할 때는 패키지가 달라도 접근 할 수 있다.

-defult : 같은 패키지에서만 접근 가능

-private : 같은 클래스에서만 접근 가능

==
변수/상수 에 사용 할 수 있는 접근제한자 : public , private , defult , protected

메서드에 사용 할 수 있는 접근제한자 : public , private , defult , protected

클래스에 사용 할 수 있는 접근제한자 : public , defult



========================================================
========================================================

인터페이스 구조
public final static (public static 상수
public abstract (public 추상메서드
반드시 위 두구조임.


DTO(Data Transfer Object)클래스 : 데이터 저장 전용 클래스
데이터를 저장할 목적으로 만들어진 클래스
=TO=VO(Value Object)= domain

1. Serializable 인터페이스 구현
2. 변수 선언 시 사용되는 접근제한자는 무조건 private
3. defult 생성자 생성(java bean)
4. 사용자 생성자 생성
5. getters/setters
6. toString( ) 오버라이딩
7. hashcode( )/eqauls( ) 오버라이딩











